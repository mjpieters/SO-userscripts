{"version":3,"file":"bookmark-users.user.js","mappings":"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","sources":["webpack:///./scripts/bookmark-users/src/constants.ts","webpack:///./scripts/bookmark-users/src/controller.ts","webpack:///./scripts/bookmark-users/src/sedeQuery.ts","webpack:///./scripts/bookmark-users/src/users.ts","webpack:///./scripts/bookmark-users/src/utils.ts","webpack:///webpack/bootstrap","webpack:///./scripts/bookmark-users/src/index.ts"],"sourcesContent":["// API key specific to this script, client id\nexport const seApiKey = '9VvY5KWke5mKcflYkx)NDw(('\nexport const seApiUrl = 'https://api.stackexchange.com/2.3'\n/*\n * Minimal subset for user queries, containing only:\n *   wrapper (backoff, error_id, error_message_, error_name, items, quota_max, quota_remaining),\n *   user (display_name, is_employee, link, profile_image, reputation, user_id, user_type)\n */\nexport const minimalUserFilter = '!)69QNaSIc2a*QW(ccD0ph0dVbliY'\nexport const sedeUrl = 'https://data.stackexchange.com/'\n// Query link: https://data.stackexchange.com/stackoverflow/query/1549808\n// The ID here is that of the _revision_ of the query.\nexport const sedeQueryId = '1894927'\n\nexport const controllerId = 'us-bookmarkers'\n\n// scale anonymous gravatar sprite in stacks minimal usercard style\nexport const userStyles = `\n.${controllerId}-content { min-height: min-content; }\n.${controllerId}-popover .s-user-card__minimal .anonymous-gravatar {\n  zoom:0.5;\n  -moz-transform:scale(0.5);\n  -moz-transform-origin: 0 0;\n}\n.${controllerId}-popover .s-user-card__minimal .s-user-card--time {\n  font-variant-numeric: tabular-nums;\n}\n`\n","/* global GM_addStyle, Stacks, StackExchange, Svg */\nimport { controllerId, userStyles } from './constants'\nimport { fetchBookmarkers } from './sedeQuery'\nimport { fetchUsers } from './users'\n\ntype State = 'initial' | 'attached' | 'loading' | 'loaded'\n\nconst bookmarkersButton = `\n  <button\n    class=\"s-btn s-btn__unset c-pointer py4\"\n    data-controller=\"s-tooltip ${controllerId}\"\n    data-s-popover-toggle-class=\"fc-yellow-600\"\n    data-s-tooltip-placement=\"right\"\n    data-action=\"click->s-popover#toggle s-popover:show->${controllerId}#showBookmarkers\"\n    aria-pressed=\"false\"\n    title=\"Show who bookmarked this question.\"\n  ></button>\n`\n// Stacks styling classes:\n// - We need an inner div so overflow changes are not affecting the popover arrow div\n// - The minimal usercards are flex items and so dictate a width that'll overflow. Limit\n//   the width of the inner popover div with wmx100 (maximum width 100% of the parent\n//   popover div)\n// - The inner div is the scroll container, with hmx3 setting the maximum height; it can\n//   be smaller if there are just a few users listed.\n// - The inner popover div is a flex container, and gs8 / gsy handles the gutter between\n//   the items, and m4 setting the margin between the outer and inner containers.\n// - The contained unordered list requires mr-auto (margin-right: auto) to compensate\n//   for flex-item shenenigans; without this the list is shifted too far left.\nconst popoverDiv = `\n  <div\n    class=\"${controllerId}-popover s-popover\"\n    role=\"dialog\"\n    aria-hidden=\"true\"\n  >\n    <div class=\"s-popover--arrow\"></div>\n    <div class=\"m4 hmx3 wmx100 overflow-x-hidden overflow-y-auto\">\n      <div\n        class=\"${controllerId}-popover-inner d-flex fd-column flex__center gs8 gsy\"\n      >\n        <ul class=\"list-reset flex--item mr-auto\"></ul>\n        <div class=\"s-spinner s-spinner__sm flex--item\">\n          <div class=\"v-visible-sr\">Loadingâ€¦</div>\n        </div>\n      </div>\n    </div>\n  </div>\n`\n\nexport class BookmarkersController extends Stacks.StacksController {\n  static style?: HTMLStyleElement = null\n\n  state: State = 'initial'\n  popoverElement?: HTMLElement\n\n  static attach(bookmarkButton?: Element): void {\n    if (\n      // If there is no bookbark button, or bookmark count is not visible, bail\n      !(\n        bookmarkButton &&\n        bookmarkButton.querySelector<HTMLElement>('.js-bookmark-count')\n          ?.offsetParent\n      )\n    ) {\n      return\n    }\n    if (!BookmarkersController.style) {\n      BookmarkersController.style = GM_addStyle(userStyles)\n    }\n    bookmarkButton.insertAdjacentHTML('afterend', bookmarkersButton)\n    bookmarkButton.nextElementSibling?.insertAdjacentElement(\n      'beforeend',\n      Svg.Person()[0]\n    )\n    Stacks.application.register(controllerId, BookmarkersController)\n  }\n\n  connect(): void {\n    if (this.state !== 'initial') {\n      return\n    }\n\n    this.state = 'attached'\n    Stacks.attachPopover(this.element, popoverDiv)\n    this.popoverElement = document.getElementById(\n      this.element.getAttribute('aria-controls')\n    )\n  }\n\n  async showBookmarkers(): Promise<void> {\n    if (this.state !== 'attached') {\n      return\n    }\n    this.state = 'loading'\n    const listElement = this.popoverElement.querySelector<HTMLElement>('ul')\n    const postId = StackExchange.question.getQuestionId()\n    const bookmarkers = await fetchBookmarkers(postId)\n    if (!bookmarkers.length) {\n      listElement.insertAdjacentHTML(\n        'beforeend',\n        '<li class=\"mb4 fs-italic\">No bookmarkers known (yet)</li>'\n      )\n      listElement.classList.add('mx-auto') // center the text\n    } else {\n      const dateForUid = new Map(bookmarkers.map((b) => [b.userId, b.date]))\n      for await (const user of fetchUsers(\n        bookmarkers.map((b) => b.userId),\n        true\n      )) {\n        listElement.insertAdjacentHTML(\n          'beforeend',\n          `<li class=\"mb4\">${user.toHTML(\n            dateForUid.get(user.user_id.toFixed(0))\n          )}</li>`\n        )\n      }\n    }\n    this.state = 'loaded'\n    this.popoverElement.querySelector<HTMLElement>('.s-spinner').remove()\n  }\n}\n","/*\n * Query the Stack Exchange Data Explorer for user ids of users who bookmarked a post\n * Uses the GM_xmlhttpRequest function + a @connect registration to get around CORS\n * limitations on that host.\n */\n/* global GM_xmlhttpRequest */\nimport { sedeUrl, sedeQueryId } from './constants'\nimport { getSiteId } from './utils'\n\ntype BookmarkedBy = {\n  date: string\n  userId: string\n}\n\nexport function fetchBookmarkers(postId: number): Promise<BookmarkedBy[]> {\n  const siteId = getSiteId()\n  return new Promise((resolve, reject) => {\n    GM_xmlhttpRequest({\n      method: 'GET',\n      url: `${sedeUrl}/${siteId}/csv/${sedeQueryId}?postId=${postId}`,\n      fetch: true,\n      onload: (response) => {\n        if (response.status !== 200) {\n          reject(new Error(`invalid response ${response}`))\n        }\n        const text = response.responseText\n        const lines = text.split(/\\r?\\n/).filter(Boolean)\n        lines.shift() // remove the header\n        resolve(\n          lines.map((line: string) => {\n            // date in YYYY-MM-DD 00:00:00 format, userId, both quoted\n            const [dateStr, userId] = line.replaceAll('\"', '').split(',')\n            const date = dateStr.split(' ')[0]\n            return { date, userId }\n          })\n        )\n      },\n    })\n  })\n}\n","/*\n * Fetch users from the Stack Exchange API and render to HTML\n */\n/* global StackExchange */\nimport { seApiFetch } from './utils'\nimport { minimalUserFilter } from './constants'\n\nconst abbreviatedRepFormat = new Intl.NumberFormat('en-US', {\n  notation: 'compact',\n  maximumSignificantDigits: 3,\n})\nconst fullRepFormat = new Intl.NumberFormat('en-US', {\n  useGrouping: true,\n})\n\n/* subset of https://api.stackexchange.com/docs/types/user */\nclass User {\n  user_id: number\n  display_name: string\n  link: string\n  profile_image: string\n  reputation: number\n  is_employee: boolean\n  user_type:\n    | 'unregistered'\n    | 'registered'\n    | 'moderator'\n    | 'team_admin'\n    | 'does_not_exist'\n\n  get badges(): string {\n    const badges = []\n    if (this.is_employee) {\n      badges.push(\n        `<span class=\"s-badge s-badge__staff s-badge__xs\">Staff</span>`\n      )\n    }\n    switch (this.user_type) {\n      case 'moderator':\n        badges.push(\n          `<span class=\"s-badge s-badge__moderator s-badge__xs\">Mod</span>`\n        )\n        break\n      case 'team_admin':\n        badges.push(\n          `<span class=\"s-badge s-badge__admin s-badge__xs\">Admin</span>`\n        )\n    }\n    return badges.join(' ')\n  }\n\n  get abbreviated_reputation(): string {\n    return this.reputation < 10000\n      ? fullRepFormat.format(this.reputation)\n      : abbreviatedRepFormat.format(this.reputation).toLowerCase()\n  }\n\n  toHTML(date: string): string {\n    return `\n      <div class=\"s-user-card s-user-card__minimal\">\n        <time class=\"s-user-card--time\">${date}</time>\n        <a href=\"${this.link}\" class=\"s-avatar s-user-card--avatar\">\n          <img class=\"s-avatar--image\" src=\"${this.profile_image}\" />\n        </a>\n        <div class=\"s-user-card--info\">\n          <a href=\"${this.link}\" class=\"s-user-card--link\"\n            >${this.display_name} ${this.badges}</a\n          >\n          <ul class=\"s-user-card--awards\">\n            <li\n              class=\"s-user-card--rep\"\n              title=\"reputation score ${fullRepFormat.format(this.reputation)}\"\n            >\n              ${this.abbreviated_reputation}\n            </li>\n          </ul>\n        </div>\n      </div>\n    `\n  }\n}\n\nclass DeletedUser extends User {\n  constructor(userId: string) {\n    super()\n    this.user_id = parseInt(userId)\n    this.link = `/users/${userId}`\n  }\n\n  toHTML(date: string): string {\n    if (StackExchange.options.user.isModerator) {\n      return `\n        <div class=\"s-user-card s-user-card__minimal s-user-card__deleted\">\n          <time class=\"s-user-card--time\">${date}</time>\n          <a href=\"${this.link}\" class=\"s-avatar s-user-card--avatar\">\n            <span class=\"anonymous-gravatar\"></span>\n          </a>\n          <div class=\"s-user-card--info\">\n            <a href=\"${this.link}\" class=\"s-user-card--link\"\n              >user${this.user_id}</a\n            >\n          </div>\n        </div>\n      `\n    }\n    return `\n      <div class=\"s-user-card s-user-card__minimal s-user-card__deleted\">\n        <time class=\"s-user-card--time\">${date}</time>\n        <div class=\"s-avatar s-user-card--avatar\">\n          <span class=\"anonymous-gravatar\"></span>\n        </a>\n        <div class=\"s-user-card--info\">\n          <div class=\"s-user-card--link\">user${this.user_id}</a>\n        </div>\n      </div>\n    `\n  }\n}\n\ntype JSONUser = {\n  [P in keyof User as User[P] extends Function ? never : P]: User[P] // eslint-disable-line @typescript-eslint/ban-types\n}\n\n// Fetch users and yield User objects in the same order they are listed in the argument\nexport async function* fetchUsers(\n  userIds: string[],\n  missingAssumeDeleted = false\n): AsyncGenerator<User, void, undefined> {\n  while (userIds.length > 0) {\n    const queryIds = userIds.splice(0, 100)\n    userIds = userIds.splice(100)\n    const results = await seApiFetch<JSONUser>(\n      `users/${queryIds.join(';')}`,\n      minimalUserFilter\n    )\n    const byUserId = new Map(\n      results.map((user) => [\n        user.user_id.toFixed(0),\n        Object.assign(new User(), user),\n      ])\n    )\n    yield* queryIds.reduce((mapped, uid) => {\n      let user = byUserId.get(uid)\n      if (user === undefined && missingAssumeDeleted) {\n        user = new DeletedUser(uid)\n      }\n      return user ? [...mapped, user] : mapped\n    }, [])\n  }\n}\n","import { seApiKey, seApiUrl } from './constants'\n\n// Get the site id for Stack Exchange API and SEDE queries\nexport function getSiteId(): string {\n  return location.hostname.replace(/(\\.stackexchange)?\\.com$/, '')\n}\n\n// Promise that delays resolution for a given number of milliseconds\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\ntype APIResponse<T> = {\n  backoff?: number\n  error_id?: number\n  error_message?: string\n  error_name?: string\n  items: T[]\n}\n\n// holds path => earliest next fetch allowed time in ms\nconst notBeforeTs: Map<string, number> = new Map()\n\n// Fetch data from the API; handles backoff, API key use and site ID transparently\nexport async function seApiFetch<T>(path: string): Promise<T[]>\nexport async function seApiFetch<T>(path: string, filter: string): Promise<T[]>\nexport async function seApiFetch<T>(\n  path: string,\n  ...[filter]: [] | [string]\n): Promise<T[]> {\n  const url = new URL(`${seApiUrl}/${path}`)\n  url.search = new URLSearchParams({\n    ...(filter && { filter }),\n    key: seApiKey,\n    site: getSiteId(),\n    pagesize: '100',\n  }).toString()\n\n  const backoffBy = (notBeforeTs.get(path) ?? 0) - new Date().getTime()\n  if (backoffBy > 0) {\n    await delay(backoffBy)\n  }\n\n  const response = await fetch(url.toString())\n  const wrapper: APIResponse<T> = await response.json()\n  notBeforeTs.set(path, new Date().getTime() + wrapper.backoff ?? 0)\n\n  if (wrapper.error_id) {\n    throw new Error(\n      `${wrapper.error_name} (${wrapper.error_id}): ${wrapper.error_message}`\n    )\n  }\n\n  return wrapper.items\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/* global StackExchange */\nimport { BookmarkersController } from './controller'\n\nStackExchange.ready(() =>\n  BookmarkersController.attach(document.querySelector('.js-bookmark-btn'))\n)\n"],"names":["seApiKey","seApiUrl","minimalUserFilter","sedeUrl","sedeQueryId","controllerId","userStyles","bookmarkersButton","popoverDiv","BookmarkersController","Stacks","StacksController","state","static","bookmarkButton","querySelector","offsetParent","style","GM_addStyle","insertAdjacentHTML","nextElementSibling","insertAdjacentElement","Svg","Person","application","register","connect","this","attachPopover","element","popoverElement","document","getElementById","getAttribute","async","listElement","postId","StackExchange","question","getQuestionId","bookmarkers","fetchBookmarkers","length","dateForUid","Map","map","b","userId","date","user","fetchUsers","toHTML","get","user_id","toFixed","classList","add","remove","siteId","getSiteId","Promise","resolve","reject","GM_xmlhttpRequest","method","url","fetch","onload","response","status","Error","lines","responseText","split","filter","Boolean","shift","line","dateStr","replaceAll","abbreviatedRepFormat","Intl","NumberFormat","notation","maximumSignificantDigits","fullRepFormat","useGrouping","User","badges","is_employee","push","user_type","join","abbreviated_reputation","reputation","format","toLowerCase","link","profile_image","display_name","DeletedUser","constructor","super","parseInt","options","isModerator","userIds","missingAssumeDeleted","queryIds","splice","results","seApiFetch","byUserId","Object","assign","reduce","mapped","uid","undefined","location","hostname","replace","delay","ms","setTimeout","notBeforeTs","path","URL","search","URLSearchParams","key","site","pagesize","toString","backoffBy","Date","getTime","wrapper","json","set","backoff","error_id","error_name","error_message","items","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","ready","attach"],"sourceRoot":""}